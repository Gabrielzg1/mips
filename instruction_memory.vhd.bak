library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity instruction_memory is
    port (
        read_address: in STD_LOGIC_VECTOR (31 downto 0);
        instructions_input: in STD_LOGIC_VECTOR (31 downto 0) array(0 to 31);
        instruction, last_instr_address: out STD_LOGIC_VECTOR (31 downto 0)
    );
end instruction_memory;

architecture behavioral of instruction_memory is

    type mem_array is array(0 to 31) of STD_LOGIC_VECTOR (31 downto 0);
    signal data_mem: mem_array := (
        others => (others => '0')
    );

    begin

    -- Processo para atualizar a memória com as instruções do testbench
    process(instructions_input)
    begin
        for i in instructions_input'range loop
            data_mem(i) <= instructions_input(i);
        end loop;
        -- Atualiza o endereço da última instrução
        last_instr_address <= std_logic_vector(to_unsigned((instructions_input'length - 1)*4, last_instr_address'length));
    end process;

    -- Desde que os registradores são múltiplos de 4 bits, podemos ignorar os últimos dois
    instruction <= data_mem(to_integer(unsigned(read_address(31 downto 2))));

end behavioral;
